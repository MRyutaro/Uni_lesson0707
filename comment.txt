1
1.
for文の中のfor文において、配列を出力する関数、show_array関数を呼び出した。不等号の位置をその関数の引数として入力するようにした。比較と交換を数える変数としてexchange_numとcomparison_numを設定し、jのfor文の中でcomparison_numを１プラスし、その中でももしA[j] > A[j]ならexchange_numを１プラスするようにした。

2.
a.exe 7 5 1 2 8 3
A = パス1:
 7 5 1 2 8 > 3
 7 5 1 2 < 3 8
 7 5 1 < 2 3 8
 7 5 > 1 2 3 8
 7 > 1 5 2 3 8
 1 7 5 2 3 8
パス2:
 1 7 5 2 3 < 8
 1 7 5 2 < 3 8
 1 7 5 > 2 3 8
 1 7 > 2 5 3 8
 1 2 7 5 3 8
パス3:
 1 2 7 5 3 < 8
 1 2 7 5 > 3 8
 1 2 7 > 3 5 8
 1 2 3 7 5 8
パス4:
 1 2 3 7 5 < 8
 1 2 3 7 > 5 8
 1 2 3 5 7 8
パス5:
 1 2 3 5 7 < 8
 1 2 3 5 7 8
比較は15回でした。
交換は8回でした。

3.
配列の出力をする関数show_arrayを設定した。その関数の引数に不等号を置く位置を設定した。その値を０にすることで不等号がない状態の配列を出力できるようにし、一つの関数で出力をできるように工夫した。

2
1.
QにエンキューをしていきそのあとデキューしながらAにソート後のデータを入れていく。そのエンキューとデキューの間に、エンキューされていく様子を出力するような処理を行う。まずは０から９までループを回す。そのループの中でまずQ[]を出力する。そしてその中にデータが入っていればA[]を出力するようにする。

2.
a.exe 1 0 3 2 6 6 0 6 2 7 5 3
Q[0] -> A[1] -> A[6] 
Q[1] -> A[0]
Q[2] -> A[3] -> A[8] 
Q[3] -> A[2] -> A[11]
Q[4]
Q[5] -> A[10]        
Q[6] -> A[4] -> A[5] -> A[7]
Q[7] -> A[9]
Q[8]
Q[9]

3.
出力をどこで行うかが難しかった。なぜならソートの前のデータが入っているAが、ソート後には保存されていないから。そのためAの値が書き換えられる前の値を使って様子を出力するようにした。

3
1.
まずは入力した値からヒープ構造を作る。そうしてできた配列において、最大値である根と、配列の末尾の値を交換する。ただしすでに根から交換してきた値は除いた値の中での末尾である。そして交換後の配列を再びヒープ構造にする。この操作をすべての値が交換されるまで繰り返す。そうするとソートされた配列ができる。

2.
a.exe 7 5 1 2 8 3
A[] = 7 5 1 2 8 3
[ 8 [ 7 2 5 ] [ 3 1 _ ] ]
8
[ 7 [ 5 2 1 ] 3 ] 
7 8
[ 5 [ 2 1 _ ] 3 ]
5 7 8
[ 3 2 1 ]
3 5 7 8 
[ 2 1 _ ]
2 3 5 7 8
A[] = 1 2 3 5 7 8

3.
前回の授業で使った木の出力用の関数を使おうとしたが、木で定義されているのではなく配列で定義されていたので出来なかった。そのため前回の授業で使った関数をもとにして、親ノードのインデックスをkとすると左の子は2K+1、右の子は2k+2になる関係を用いて、ヒープ構造を出力できるような関数を作った。